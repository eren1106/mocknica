generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Project {
  id            String   @id @default(cuid())
  name          String
  description   String?
  permission    ProjectPermission @default(PUBLIC)
  isNeedToken   Boolean  @default(false)
  token         String?  @unique // Generated token for API access
  corsOrigins   String[] @default([]) // List of allowed CORS origins
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoints     Endpoint[]
  schemas       Schema[]
  responseWrappers ResponseWrapper[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Endpoint {
  id                String           @id @default(cuid())
  description       String
  method            HttpMethod       @default(GET)
  path              String
  staticResponse    Json
  schemaId          Int?
  schema            Schema?          @relation(fields: [schemaId], references: [id])
  responseWrapperId Int?
  responseWrapper   ResponseWrapper? @relation(fields: [responseWrapperId], references: [id])
  isDataList        Boolean          @default(false) // if schema is used in the endpoint, then will need to check the data is return in list or not
  numberOfData      Int? // if isDataList is true, then this field will be used to determine the number of data to return
  projectId         String
  project           Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
}

model Schema {
  id        Int           @id @default(autoincrement())
  name      String
  fields    SchemaField[] @relation("FieldToParentSchema")
  projectId String?
  project   Project?      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  ArrayType    ArrayType[]
  ObjectFields SchemaField[] @relation("FieldToObjectSchema")
  Endpoints    Endpoint[]
}

model SchemaField {
  id   Int             @id @default(autoincrement())
  name String
  type SchemaFieldType

  // if type is id
  idFieldType IdFieldType?

  // if type is faker
  fakerType FakerType?

  schemaId Int?
  Schema   Schema? @relation("FieldToParentSchema", fields: [schemaId], references: [id])

  // if type is object and selected object type is not empty object
  objectSchemaId Int?
  objectSchema   Schema? @relation("FieldToObjectSchema", fields: [objectSchemaId], references: [id])

  // if type is array
  arrayTypeId Int? // Foreign key to ArrayType.id
  arrayType   ArrayType? @relation("SchemaFieldToArrayType", fields: [arrayTypeId], references: [id])
}

model ArrayType {
  id          Int             @id @default(autoincrement())
  elementType SchemaFieldType

  // if type is object
  objectSchemaId Int?
  objectSchema   Schema? @relation(fields: [objectSchemaId], references: [id])

  // if type is faker
  fakerType FakerType?

  SchemaFields SchemaField[] @relation("SchemaFieldToArrayType")
}

model ResponseWrapper {
  id        Int        @id @default(autoincrement())
  name      String     @db.VarChar(255)
  // TODO: change json to response
  json      Json
  projectId String?
  project   Project?   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  Endpoint  Endpoint[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

enum HttpMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

enum ProjectPermission {
  PUBLIC
  PRIVATE
}

enum IdFieldType {
  UUID
  AUTOINCREMENT
}

enum SchemaFieldType {
  ID
  FAKER
  STRING
  INTEGER
  FLOAT
  BOOLEAN
  OBJECT
  ARRAY
  DATE
}

// fakerjs types
enum FakerType {
  // Person
  FIRST_NAME
  LAST_NAME
  FULL_NAME
  JOB_TITLE
  PHONE_NUMBER

  // Internet
  EMAIL
  USER_NAME
  PASSWORD
  URL
  IP_ADDRESS

  // Location
  CITY
  COUNTRY
  STATE
  STREET_ADDRESS
  ZIP_CODE
  LATITUDE
  LONGITUDE

  // Business
  COMPANY_NAME
  DEPARTMENT
  PRODUCT_NAME
  PRICE

  // Date & Time
  PAST_DATE
  FUTURE_DATE
  RECENT_DATE

  // Finance
  CREDIT_CARD_NUMBER
  ACCOUNT_NUMBER
  AMOUNT
  CURRENCY

  // Text
  WORD
  SENTENCE
  PARAGRAPH

  // System
  FILE_NAME
  DIRECTORY_PATH
  MIME_TYPE

  // Identifiers
  UUID
  DATABASE_ID
}

// Better Auth Models
model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  accounts Account[]
  sessions Session[]
  projects Project[]
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
}
