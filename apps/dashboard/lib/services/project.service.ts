import { IProject, IProjectLight } from "@/types";
import { ProjectSchemaType } from "@/zod-schemas/project.schema";
import { projectRepository as projectRepo, ProjectRepository } from "@/lib/repositories";
import { PrismaIncludes } from "@/lib/repositories/prisma-includes";
import { mapProject, mapProjectLight } from "@/lib/repositories/type-mappers";
import { AppError, ERROR_CODES, handlePrismaError } from "@/lib/errors";
import { STATUS_CODES } from "@/constants/status-codes";
import { generateApiToken } from "@/lib/utils";
import { Prisma } from "@prisma/client";

export class ProjectService {
  constructor(private readonly projectRepository: ProjectRepository = projectRepo) {}

  /**
   * Create a new project for a user
   */
  async createProject(data: ProjectSchemaType, userId: string): Promise<IProject> {
    try {
      // Business logic: token generation based on isNeedToken
      const projectData: Prisma.ProjectCreateInput = {
        name: data.name,
        description: data.description,
        isNeedToken: data.isNeedToken || false,
        user: { connect: { id: userId } },
        token: data.isNeedToken ? generateApiToken() : undefined,
      };

      const createdProject = await this.projectRepository.create(projectData);
      
      if (!createdProject) {
        throw new AppError("Failed to create project", STATUS_CODES.INTERNAL_SERVER_ERROR, ERROR_CODES.INTERNAL_ERROR);
      }

      // TODO: create endpoints and schemas that generated by AI
      return mapProject(createdProject);
    } catch (error) {
      throw handlePrismaError(error);
    }
  }

  /**
   * Get a specific project by ID with ownership validation
   */
  async getProject(projectId: string, userId: string): Promise<IProject> {
    try {
      const project = await this.projectRepository.findByIdAndUserId(projectId, userId, PrismaIncludes.projectInclude);
      
      if (!project) {
        throw new AppError(
          "Project not found or access denied",
          STATUS_CODES.NOT_FOUND,
          ERROR_CODES.NOT_FOUND
        );
      }

      return mapProject(project);
    } catch (error) {
      throw handlePrismaError(error);
    }
  }

  /**
   * Get all projects for a user
   * Returns light version for better performance in list views
   */
  async getUserProjects(userId: string): Promise<IProjectLight[]> {
    try {
      const projects = await this.projectRepository.findByUserId(userId, PrismaIncludes.projectLightInclude);
      return projects.map(mapProjectLight);
    } catch (error) {
      throw handlePrismaError(error);
    }
  }

  /**
   * Update a project with ownership validation
   */
  async updateProject(
    projectId: string, 
    data: Partial<ProjectSchemaType>, 
    userId: string
  ): Promise<IProject> {
    try {
      // Verify ownership first
      await this.getProject(projectId, userId);
      
      // Business logic: handle token generation/removal based on isNeedToken
      const currentProject = await this.projectRepository.findById(projectId, { select: { token: true, isNeedToken: true } });
      
      const updateData: Prisma.ProjectUpdateInput = {
        ...data,
        token: data.isNeedToken !== undefined 
          ? (data.isNeedToken ? (currentProject?.token || generateApiToken()) : null)
          : undefined,
      };

      const entity = await this.projectRepository.update(projectId, updateData);
      const fullProject = await this.projectRepository.findById(entity.id, PrismaIncludes.projectInclude);
      
      if (!fullProject) {
        throw new AppError("Failed to update project", STATUS_CODES.INTERNAL_SERVER_ERROR, ERROR_CODES.INTERNAL_ERROR);
      }

      return mapProject(fullProject);
    } catch (error) {
      throw handlePrismaError(error);
    }
  }

  /**
   * Delete a project with ownership validation
   */
  async deleteProject(projectId: string, userId: string): Promise<void> {
    try {
      // Verify ownership first
      await this.getProject(projectId, userId);
      
      await this.projectRepository.delete(projectId);
    } catch (error) {
      throw handlePrismaError(error);
    }
  }

  /**
   * Verify if user owns a project
   */
  async verifyProjectOwnership(projectId: string, userId: string): Promise<boolean> {
    try {
      return await this.projectRepository.existsByIdAndUserId(projectId, userId);
    } catch (error) {
      return false;
    }
  }
}

// Export singleton instance
export const projectService = new ProjectService();
